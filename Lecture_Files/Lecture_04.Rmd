---
# title: "Lecture 03"
# author: "Kasthuri Kannan"
# date: "Sept 07, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

### R fundamentals 03: Elements of programming  (Sept. 19, 2017)

---

As the last part of R fundamentals series, we will study elements of R programming.

---

#### Conditional statements and operators in R

R provides syntax to evaluate conditions. 

```{r eval=FALSE}
  if (condition) {
    expression
  }
```

As an example,

```{r eval=TRUE}
  # Assign x to -8
  x <- -8
  # Print if x is negative
  if (x < 0) {
    print("x is a negative number")
  }
```

<br>
<span style="color:magenta">**Classwork**</span>: Change x to 5 and re-run the above code. What does that print?

<br>

```{r eval=FALSE}
  if (condition) {
    expression 1
  }
  else {
    expression 2
  }
```


<br>
<span style="color:magenta">**Classwork**</span>: Evaluate the above code with the else statement printing "x is positive or zero", when it is.

<br>


```{r eval=FALSE}
  if (condition) {
    expression 1
  }
  else if {
    expression 2
  }
  else {
    expression 3
  }
```

R provides logical operators:

* AND with symbol &
* OR with symbol |
* NOT with symbol !

```{r eval=FALSE}
  # AND truth table
  TRUE  & TRUE   : TRUE
  TRUE  & FALSE  : FALSE
  FALSE & TRUE   : FALSE
  FALSE & FALSE  : FALSE
```

Example: `x <- 5` and `(x >3) & (x <8)` will evaluate to `TRUE`.

```{r eval=FALSE}
  # OR truth table
  TRUE  | TRUE   : TRUE
  TRUE  | FALSE  : TRUE
  FALSE | TRUE   : TRUE
  FALSE | FALSE  : FALSE
```

Example: `x <- 5` and `(x >5) | (x <8)` will evaluate to `FALSE`.

```{r eval=FALSE}
  # NOT truth table
  !TRUE  : FALSE
  !FALSE : TRUE
```

Example:  `x <- 5` and `!((x >5) | (x <8))` will evaluate to `TRUE`.

<br>
<span style="color:magenta">**Classwork**</span>: Create an R script that returns the max value of a vector x with length 3. Donâ€™t use the aid of an auxiliary variable.
<br>

**Note**: R comes out of the loop as soon as the condition is met. It will **not** evaluate further conditions down the line even if they satisfy.

```{r eval=TRUE}
  # Assign x to 6
  x <- 6
  # Check if x is divisible by 2 or 3, if so print it is
  # Otherwise print it is not
  if (x %% 2 == 0) {
    print("x is divisioble by 2")
  } else if(x %% 3 == 0) {
    print("x is divisible by 3")
  } else {
    print("x is neither divisible by 2 nor 3")
  }
```

We can apply logical operators on vectors and matrices - works element wise:

`c(TRUE,TRUE,FALSE) & c(FALSE,TRUE,TRUE)` will evaluate to `FALSE TRUE FALSE`.

`c(TRUE,TRUE,FALSE) | c(FALSE,TRUE,TRUE)` will evaluate to `TRUE TRUE TRUE`.

Also, we have `&&` and `||` operators in R. The difference between single `&`and `&&`is that, `&&` will only look at the first elements of the vectors. Similarly for `||`. Thus,

`c(TRUE,TRUE,FALSE) && c(FALSE,TRUE,TRUE)` will evaluate to `FALSE` and 

`c(TRUE,TRUE,FALSE) | c(FALSE,TRUE,TRUE)` will evaluate to `TRUE`.

We can check two objects are equal by the `==` sign or inequality using `!=` operator. 

```{r eval=TRUE}
  # Check the quality of logical objects
  TRUE == TRUE
  # Check the quality of logical objects
  TRUE == FALSE
  # Compare strings
  "hi" == "hello"
  # Or numbers
  2 == 2
  # Check inequlaity
  2 != 3
```

In fact, we can use comparison operators for objects!

```{r eval=TRUE}
  # Use comparison on objects
  "hello" >= "goodbye"
  # How about on logicals?
  TRUE < FALSE
```

Why is the comparison `TRUE < FALSE` evaluates to `FALSE` despite the fact that `T < F` in R? Becuase logicals are _coerced_. `TRUE` coresponds to 1 and `FALSE` to 0. We can also use comparison operators on vectors.

<br>
<span style="color:magenta">**Classwork**</span>: 

1. Compare two vectors of equal length and output the result.
2. How about vectors of unequal length? Why does the result makes sense?
3. Compare two matrices and lists and explain how R handles such comparisons.

<br>

---

#### Functions and data structures in R

The general syntax of a function:

```{r eval=FALSE}
  
  my_function <- function(arg 1, agr 2) {
    body of the function
  }
```

Unlike some other languages, in R, there is no special syntax for naming a function. One just defines like any other vector. 

Consider a simple function,

```{r eval=FALSE}
  # The add function
  add <- function(x, y=1) {
    x+y
  }
```

If y is not given any value, it will take the default argument. There is no difference between the functions we define and R supplied functions. There are three components foe every function, the formal, the body and the environment.

```{r eval=TRUE}
  # The add function
  add <- function(x, y=1) {
    x+y
  }
  # Print the formals arguments
  formals(add)
  # Print the body 
  body(add)
  # Print the environment
  environment(add)
```

Environment is typically invisible, but it is important on how the function behaves. We will soon see scope for functions. In this case the environment is the global environment.

<br>
<span style="color:magenta">**Classwork**</span>: What does this function do?

```{r eval=FALSE}
  f <- function(x) {
          if (x<0) {
              -x
          } else {
               x
            }
        }
```

<br>

Functions are just objects in R and act like any other object. You can assign a function to any other object and the object will behave exactly like the assigned function. Function need not have any name - they are called anonymous functions. Anonymous functions has to be called in one line. For example, `(function (x) {x+1})(2)` is an increment function that will produce the output 3.

##### Scoping

R looks into the function scope for values.

```{r eval=TRUE}
  # Assign the value 10 for x
  x <- 10
  # Define a function f that returns a vector
  f <- function() {
    x <- 1
    y <- 3
    c(x,y)
  }
  # Print the function
  f()
```

If the value is not in the scope, it looks one level above.

```{r eval=TRUE}
  # Assign the value 10 for x
  x <- 10
  # Define a function f that returns a vector
  f <- function() {
    y <- 3
    c(x,y)
  }
  # Print the function 
  # Note x is not in the scope
  f()
```

<br>
<span style="color:magenta">**Classwork**</span>: Use `rm(x)` in the above code to remove x from the global environment and report what happens when you call the function.

<br>

Scoping defines _where_ and not _when_ to look for a function. 

```{r eval=TRUE}
  # Define a function
  f <- function() x
  x <- 15
  f()
  x <- 20
  f()
```


This is a highly undersirable behaviour. So always as a practice design functions using the variables you'll use and not leave it to the environment. 

Lookup works the same for functions when it comes to scoping.

```{r eval=TRUE}
  # Define a function l
  l <- function() x + 20
  # Define another function and define l inside f
  f <- function() {
        l <- function(x) x +15
        l(20)
  }
  f()

```

If you use name like a function, R ignores any non-function objects when it looks it up. Here is an example:

```{r eval=TRUE}
  # Define c
  c <- 20
  # Use c as a combine 
  # R ignores the function aspect of c
  c(c=c)
```

Each call to a function has its own clean environment.

```{r eval=TRUE}
  # Define a function
  f <- function() {
    if (!exists("a")) {
      a <- 10
    } else {
      a <- a + 1
    }
    print(a)
  }
 f()
```

Everytime the working environment for this function is empty and so it is going to print only 10.

---

#### Selected materials and references

[An Introduction to R](https://cran.r-project.org/doc/manuals/R-intro.pdf)

---